<!DOCTYPE html><html lang="en"><head><title>index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="index"><meta name="groc-project-path" content="README.md"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path">README.md</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="enofjs">EnoFJS</h1>
<p><a href="https://drone.io/github.com/EnoF/EnoFJS/latest"><img src="https://drone.io/github.com/EnoF/EnoFJS/status.png" alt="Build Status"></a>
<a href="https://codeclimate.com/github/EnoF/EnoFJS"><img src="https://codeclimate.com/github/EnoF/EnoFJS.png" alt="Code Climate"></a>
<a href="https://coveralls.io/r/EnoF/EnoFJS?branch=master"><img src="https://coveralls.io/repos/EnoF/EnoFJS/badge.png?branch=master" alt="Coverage Status"></a></p>
<h2 id="inheritance">Inheritance</h2>
<p>Javascript supports private and public out of the box. However
inheritance is often claimed impossible or done with prototype.</p>
<p>While inheriting with prototype is not necessarily bad, it
however implies that all inheritable properties have to be public
and all properties should be public in case a function in the
prototype needs to access it.</p>
<p>To make this possible, EnoFJS implements a ClassFactory, handling
all the trouble of scoping and inheriting.</p>
<pre><code>var Dog = clazz(function Dog(name){
    this.extend = &#39;Animal&#39;;

    this.private = {
        name: null
    };

    this.protected = {
        nickName: {
            getSet: null
        }
    };

    this.public = {
        barkName: function barkName(){
            return &#39;Woof, my name is &#39; + this.private.name +
                &#39;, but you can call me &#39; +
                this.protected.nickName + &#39;!&#39;;
        }
    };

});
var dog = new Dog(&#39;fluffy duffy&#39;);
dog.setNickName(&#39;fluffy&#39;);
expect(dog.barkName()).
    toEqual(&#39;Woof, my name is fluffy duffy&#39; +
            &#39;, but you can call me fluffy!&#39;);</code></pre>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<p>A LinkedHashMap has the advantage of a LinkedList, able to quickly
add or remove a Node between already existing nodes. However a LinkedList is slower
in finding an entry in the middle of the list, because it has to search
through the entire list!</p>
<p>With the implementation of a LinkedHashMap, it keeps the ability to insert
or remove nodes like a LinkedList. For searching the implementation of a HashMap
is used. This way you have best of both worlds!</p>
<pre><code>var list = new LinkedHashMap();
list.add(0, &#39;one&#39;);
list.add(1, &#39;two&#39;);
list.add(2, &#39;three&#39;);
expect(list.getById(1).getValue()).toEqual(&#39;two&#39;);
list.addAfter(1, &#39;an non integer key&#39;, &#39;four&#39;);
expect(list.getById(&#39;an non integer key&#39;).getNext().
                    getValue()).toEqual(&#39;three&#39;);</code></pre>
<h2 id="serializable">Serializable</h2>
<p>When sending information over the line in <code>json</code> format, the <code>Serializable</code> clazz can help. This Class will help you
in serializing your classes into a <code>json</code> format.</p>
<p>The class also helps you deserialize a serialized object in <code>json</code> format.</p>
<pre><code>var SerializableObject = clazz(function SerializableObject(){
    this.extend = &#39;Serializable&#39;;

    this.constructor = function constructor(serialized){
        this.super(serialized);
    };
});</code></pre>
<h2 id="whereit">WhereIt</h2>
<p>The <code>whereIt</code> is an extention for the Jasmine test framework. Often you have a test cases
where the same process will be executed with different parameters, expecting different
results. The <code>whereIt</code> assists in doing this with a simple configuration!</p>
<p>Configuration will be matched to the variable names!</p>
<pre><code>whereIt(&#39;should add&#39;, function addNumbers(x, y, result){
    expect(calulator.add(x, y)).toEqual(result);
}, [
    {
        x: 1,
        y: 2,
        result: 3
    },
    {
        y: 200,
        x: 2,
        result: 202
    }
]);</code></pre>
<h2 id="arrayconverters">ArrayConverters</h2>
<p>In modern browsers <code>TypedArrays</code> are introduced. The literal array <code>[]</code> or <code>new Array()</code>
do not support the <code>ArrayBuffer</code> out of the box. To convert an literal array into an
<code>Uint32Array</code> this extention on the <code>Array.prototype</code> is brought to live.</p>
<p>Usage:</p>
<pre><code>var array = [1,2,3,4];
var uInt32Array = array.toUint32Array();
console.log(uInt32Array[0]); // 67305985
uInt32Array[0] = uInt32Array[0] + 1;
array.readUint32ArrayIn(uInt32Array);
console.log(array); // [2, 2, 3, 4]</code></pre></div></div></div></div></body></html>